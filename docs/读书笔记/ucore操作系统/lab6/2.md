#### 练习2：实现 Stride Scheduling 调度算法

实现在`kern/schedule/default_sched.c`中的五个函数，实现如下：

- `stride_init`

```c
static void
stride_init(struct run_queue *rq) {
     /* LAB6: YOUR CODE 
      * (1) init the ready process list: rq->run_list
      * (2) init the run pool: rq->lab6_run_pool
      * (3) set number of process: rq->proc_num to 0       
      */
      list_init(&(rq->run_list));
      rq->lab6_run_pool = NULL;
      rq->proc_num = 0;
}
```

进行初始化操作，将运行队列置空，同时将`proc_num`置零。

- `stride_enqueue`

```c
static void
stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
     /* LAB6: YOUR CODE 
      * (1) insert the proc into rq correctly
      * NOTICE: you can use skew_heap or list. Important functions
      *         skew_heap_insert: insert a entry into skew_heap
      *         list_add_before: insert  a entry into the last of list   
      * (2) recalculate proc->time_slice
      * (3) set proc->rq pointer to rq
      * (4) increase rq->proc_num
      */
#if USE_SKEW_HEAP
    rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f);
#else
    list_add_before(&(rq->run_list), &(proc->run_link));
#endif
    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
        proc->time_slice = rq->max_time_slice;
    }
    proc->rq = rq;
    rq->proc_num++;
}
```

这里需要根据是否使用优先级队列来进行不同的操作，如果使用，直接插入，否则插入到链表末端。将`proc->rq`置为当前`rq`，同时将`proc_num`加一。

- `stride_dequeue`

```c
static void
stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
     /* LAB6: YOUR CODE 
      * (1) remove the proc from rq correctly
      * NOTICE: you can use skew_heap or list. Important functions
      *         skew_heap_remove: remove a entry from skew_heap
      *         list_del_init: remove a entry from the  list
      */
#if USE_SKEW_HEAP
    rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, &(proc->lab6_run_pool), proc_stride_comp_f);
#else
    list_del_init(&(proc->run_link));
#endif
    rq->proc_num--;
}
```

将进程从数据结构中删除，同时`proc_num`减一。

- `stride_pick_next`

```c
static struct proc_struct *
stride_pick_next(struct run_queue *rq) {
     /* LAB6: YOUR CODE 
      * (1) get a  proc_struct pointer p  with the minimum value of stride
             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
             (1.2) If using list, we have to search list to find the p with minimum stride value
      * (2) update p;s stride value: p->lab6_stride
      * (3) return p
      */
#if USE_SKEW_HEAP
    if (!rq->lab6_run_pool) {
        return NULL;
    }
    struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
#else
    list_entry_t *le = list_next(&(rq->run_list));
    if(le == &(rq->run_list)) {
        return NULL;
    }

    struct proc_struct *p = le2proc(le, run_link);
    for (le = list_next(le); le != &(rq->run_list); le = list_next(le)) {
        struct proc_struct *p1 = le2proc(le, run_link);
        if((int32_t)(p->lab6_stride - p1->lab6_stride) < 0) {
            p = p1;
        }
    }
#endif
    if(p->lab6_priority == 0) {
        p->lab6_stride += BIG_STRIDE;
    }
    else {
        p->lab6_stride += BIG_STRIDE / p->lab6_priority;
    }
    return p;
}
```

首先需要针对不同的数据结构，找到下一个选择的进程。如果是优先级队列，堆顶端的进程即为结果，否则需要遍历链表，找到`lab6_stride`最小的进程。然后根据算法将`lab6_stride`加上`BIG_STRIDE / p->lab6_priority`.

- `stride_proc_tick`

```c
static void
stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
     /* LAB6: YOUR CODE */
    if(proc->time_slice > 0) {
        proc->time_slice--;
    }
    if(proc->time_slice == 0) {
        proc->need_resched = 1;
    }
}
```

判断当前进程的时间片个数是否大于零，如果是则减一，否则将`need_resched`置1，在下次时钟中断时进行切换进程。

执行`make run-priority`，得到的结果如下：

```
kernel_execve: pid = 2, name = "priority".
main: fork ok,now need to wait pids.
child pid 6, acc 740000, time 1001
child pid 7, acc 912000, time 1002
child pid 4, acc 380000, time 1003
child pid 5, acc 560000, time 1003
child pid 3, acc 196000, time 1004
main: pid 3, acc 196000, time 1005
main: pid 4, acc 380000, time 1005
main: pid 5, acc 560000, time 1005
main: pid 6, acc 740000, time 1005
main: pid 7, acc 912000, time 1005
main: wait pids over
stride sched correct result: 1 2 3 4 5
all user-mode processes have quit.
```

可以看到，程序可以正常运行。
