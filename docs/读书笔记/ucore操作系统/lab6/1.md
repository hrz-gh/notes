#### 练习1：使用 Round Robin 调度算法

**问题1.1：请理解并分析`sched_calss`中各个函数指针的用法，并结合Round Robin调度算法描ucore的调度执行过程。**

`sched_class`的定义在`kern/schedule/sched.h`中：

```c
struct sched_class {
    // the name of sched_class
    const char *name;
    // Init the run queue
    void (*init)(struct run_queue *rq);
    // put the proc into runqueue, and this function must be called with rq_lock
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    // get the proc out runqueue, and this function must be called with rq_lock
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    // choose the next runnable task
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    // dealer of the time-tick
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
    /* for SMP support in the future
     *  load_balance
     *     void (*load_balance)(struct rq* rq);
     *  get some proc from this rq, used in load_balance,
     *  return value is the num of gotten proc
     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);
     */
}
```

在`sched.c`中，实例化一个`sched_class`对象为`sched_class = &default_sched_class`，并进行初始化。在后续进行进程选择和切换的时候，分别调用`sched_class_enqueue` `sched_class_pick_next` `sched_class_dequeue`函数调用`sched_class`类中的函数指针，执行相应的功能。

在Round Robin调度算法中，通过将`default_sched_class`指向为相应的实现，即可使用RR调度算法。

```c
struct sched_class default_sched_class = {
    .name = "RR_scheduler",
    .init = RR_init,
    .enqueue = RR_enqueue,
    .dequeue = RR_dequeue,
    .pick_next = RR_pick_next,
    .proc_tick = RR_proc_tick,
};
```

**问题1.2：请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计**

1. 首先维护多个链表，每个链表保存优先级不同的就绪队列
2. 进程在初始化时首先插入优先级最高的队列等待
3. 在调度时，从优先级最高的队列中开始寻找进程，若为空则进入下一优先级队列寻找
4. 对于某个进程，如果在规定的时间片内没有完成，则将其插入下一优先级队列的链表中

