#### 练习2：为新创建的内核线程分配资源

在kern/process/proc.c中完成do\_fork()函数，增加以下代码：

```c
	proc = alloc_proc();
	if(proc == NULL) goto fork_out;

    proc->parent = current;

    if(setup_kstack(proc) != 0) goto bad_fork_cleanup_proc;
    if(copy_mm(clone_flags, proc) != 0) goto bad_fork_cleanup_kstack;
    copy_thread(proc, stack, tf);

    bool flag;
    local_intr_save(flag);
    {
    proc->pid = get_pid();
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process++;
    }
    local_intr_restore(flag);

    wakeup_proc(proc);
    ret = proc->pid;
```

代码执行步骤为：

1. 分配并初始化进程控制块（alloc\_proc函数）；
2. 分配并初始化内核栈（setup\_stack函数）；
3. 根据clone\_flag标志复制或共享进程内存管理结构（copy\_mm函数）；
4. 设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（copy\_thread函数）；
5. 把设置好的进程控制块放入hash\_list和proc\_list两个全局进程链表中；
6. 自此，进程已经准备好执行了，把进程状态设置为“就绪”态；
7. 设置返回码为子进程的id号。

**问题2.1：请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。**

是。在do\_fork函数中，通过get\_pid函数为新进程分配一个pid。而在get\_pid的实现中，通过遍历进程链表，找到一个唯一的pid返回。

