#### 练习1：实现first-fit连续物理内存分配算法

修改default_pmm.c中default\_alloc\_pages函数和default\_free\_pages函数，实现first\_fit内存分配算法。 

实现中所用到的数据结构为双向链表，采用实验指导书中介绍的方法，在一块连续的页空间内，使用地址最小的一页（Head Page）记录这块内存地址的大小，并通过成员变量page\_link来维护链表结构。具体的实现如下：

```c
static struct Page *
default_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            page = p;
            break;
        }
    }
    //将剩余空闲区域由添加到链表头改至按地址排序的位置
    if (page != NULL) {
        struct Page *p = page;
        if (page->property > n) {
            p = page + n;
            p->property = page->property - n;
            //Page.flags只在头一页有用，其余空闲页全为0
            SetPageProperty(p);
            page->property = n;
            list_add(&page->page_link, &(p->page_link));
        }
        list_del(&(page->page_link));
        nr_free -= n;
    }
    return page;
}
```

分配内存主要分为以下几个步骤：

1. 判断空闲地址空间是否大于所需空间
2. 从free_list开始，遍历链表，直到找到第一块不小于所需空间大小的内存块
3. 分配连续的n页，修改标志位
4. 从链表中删除此内存块，如果有剩余的小的内存块，重新插入链表

释放内存的函数实现为：

```c
static void
default_free_pages(struct Page *base, size_t n) {
    assert(n > 0);
    struct Page *p = base;
    for (; p != base + n; p ++) {
        //释放区域不是操作系统空间且不含空闲区域的头页
        assert(!PageReserved(p) && !PageProperty(p));
        p->flags = p->property = 0;
        set_page_ref(p, 0);
    }
    base->property = n;
    SetPageProperty(base);
    while (le != &free_list) {
        p = le2page(le, page_link);
        le = list_next(le);
        // 寻找可以合并的空间
        if (base + base->property == p) {
            base->property += p->property;
            ClearPageProperty(p);
            list_del(&(p->page_link));
            //由于是first-fit空闲块按地址排序，找到了可以break跳出循环
            break; 
        }
        else if (p + p->property == base) {
            p->property += base->property;
            ClearPageProperty(base);
            base = p;
            list_del(&(p->page_link));
        }
    }
    nr_free += n;
    le = list_next(&free_list);
    // 插入空闲链表
    while (le != &free_list) {
        p = le2page(le, page_link);
        if (base + base->property <= p) {
            assert(base + base->property != p);
            break;
        }
        le = list_next(le);
    }
    list_add_before(le, &(base->page_link));
}
```

主要分为以下步骤：

1. 修改释放页的标志位
2. 找到链表中应该插入的位置并插入
3. 判断此块空余空间能否与前后空余空间合并，如果可以将其合并

**问题1.1： 你的first fit算法是否有进一步的改进空间**

有，可以采用平衡树的数据结构维护空闲地址空间，这样在分配和回收空间时，查找内存的操作可以更快。