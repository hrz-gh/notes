#### 练习2：实现寻找虚拟地址对应的页表项

修改pmm.c中的get_pte函数，增加下面代码：

```c
	pde_t *pdep = &pgdir[PDX(la)];
    if (!(*pdep & PTE_P)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep = pa | PTE_U | PTE_W | PTE_P;
    }
    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
```

代码主要分为以下几个步骤：

1. 根据虚地址的高十位查询页目录，找到页表项的pdep
2. 检查该页是否在内存中，如果不在，创建该页，并更新相关信息
3. 根据虚拟地址的中间十位，找到虚拟地址对应的页表项

**问题2.1：请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。**

```
页目录项内容 = (页表起始物理地址 & ~ 0x0FFF) | PTE_U | PTE_W | PTE_P
页表项内容 = (pa & ~0x0FFF) | PTE_P | PTE_W
```

页目录项和页表项的高20位存储相应的物理页帧号，低12位存储标志位。标志位的定义为：

```c
#define PTE_P           0x001                   // Present
#define PTE_W           0x002                   // Writeable
#define PTE_U           0x004                   // User
#define PTE_PWT         0x008                   // Write-Through
#define PTE_PCD         0x010                   // Cache-Disable
#define PTE_A           0x020                   // Accessed
#define PTE_D           0x040                   // Dirty
#define PTE_PS          0x080                   // Page Size
#define PTE_MBZ         0x180                   // Bits must be zero
#define PTE_AVAIL       0xE00                   // Available for software use
                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
                                                // hardware, so user processes are allowed to set them arbitrarily.

```

**问题2.2：如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

在页机制启动后，但中断向量表未加载时，会停机崩溃。