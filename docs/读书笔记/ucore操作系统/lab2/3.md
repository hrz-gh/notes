#### 练习3：释放某虚地址所在的页并取消对应二级页表项的映射

修改pmm.c中的page\_remove\_pte函数。

```c
if (*ptep & PTE_P) {
    struct Page *page = pte2page(*ptep);
    if (page_ref_dec(page) == 0) {
        free_page(page);
    }
    *ptep = 0;
    tlb_invalidate(pgdir, la);
}
```

代码执行步骤为：

1. 找到页表项对应的物理页帧
2. 将页的对应的被引用次数减一
3. 如果ref为0，释放该页
4. 清除页表项，并更新tlb

**问题3.1：数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**

在pmm.c的page\_init函数中：

```c
npage = maxpa / PGSIZE;
pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);

for (i = 0; i < npage; i ++) {
    SetPageReserved(pages + i);
}

uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
```

从中可以看出，首先计算出页的总数npage，然后分配内存pages为Page数组的头指针，并对npage项初始化。可见每一项对应物理空间的每一页。页表项中的基址为物理地址，可以转化为Page中相应的项。

**问题3.2：如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？鼓励通过编程来具体完成这个问题**

修改memlayout.h：

```c
#define KERNBASE     0x00000000
#define VPT          0x3AC00000
```
修改kernel.ld：

```
. = 0x00100000;
```

在entry.s中去掉置boot_pgdir[0]为0的项，因为此时虚地址与实地址一一对应：

```asm
#   xorl %eax, %eax
#   movl %eax, __boot_pgdir
```
