#### 练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

**问题1.1：给出内核级信号量的设计描述，并说其大致执行流流程。**

内核级信号量的定义在`kern/sync/sem.h`中：

```c
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```

`value`用于表示信号量中资源的整数值，`wait_queue`表示等待队列。
对于信号量存在以下几种操作：

1. `sem_init(semaphore_t *sem, int value)`: 初始化信号量，设置`value`并新建一个等待队列
2. `void up(semaphore_t *sem)`: V操作，调用`__up()`函数实现。
3. `void down(semaphore_t *sem)`: P操作，调用`__down()`函数实现。
4. `bool try_down(semaphore_t *sem)`: 非阻塞的P操作，如果信号量的`value`大于0，则直接减一。

从以上的操作中可以看出，关于信号量的核心的实现为`__up()`和`__down()`函数。下面对这两个函数做进一步分析。

```c
static __noinline void __up(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        wait_t *wait;
        if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {
            sem->value ++;
        }
        else {
            assert(wait->proc->wait_state == wait_state);
            wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);
        }
    }
    local_intr_restore(intr_flag);
}
```

V操作的执行过程分为以下步骤：

- 关中断
- 判断等待队列是否为空，若为空，将`value`值加一
- 否则，调用`wake_up`将睡眠的进程唤醒
- 开中断返回

```c
static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    if (sem->value > 0) {
        sem->value --;
        local_intr_restore(intr_flag);
        return 0;
    }
    wait_t __wait, *wait = &__wait;
    wait_current_set(&(sem->wait_queue), wait, wait_state);
    local_intr_restore(intr_flag);

    schedule();

    local_intr_save(intr_flag);
    wait_current_del(&(sem->wait_queue), wait);
    local_intr_restore(intr_flag);

    if (wait->wakeup_flags != wait_state) {
        return wait->wakeup_flags;
    }
    return 0;
}
```

P操作的执行过程分为以下步骤：

- 关中断
- 判断信号量的`value`是否大于0，如果是，则将`value`减一后开中断返回
- 否则，将当前进程加入到等待队列，开中断。执行`schedule`进行进程调度
- 如果被唤醒，则关中断
- 从等待队列中删除此进程
- 开中断并返回

**问题1.2：给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。**

由于实现信号量机制需要包含开关中断的操作，所以在用户态无法直接执行，需要系统调用来完成用户态的信号量机制。可以增加与信号量相关的系统调用，比如`SYS_SEMINIT`,`SYS_UP`,`SYS_DOWN`等。

相同点：实现机制相同
不同点：用户态需要系统调用









​    

