#### 笔记

**copy_mm()**

内核线程的mm是空指针。	

**kernel_execve()**

`T_SYSCALL`（0x80）为系统调用中断号，`SYS_exec`（4）存入eax中，为功能号。**kernel_execve() - > syscall()**

```
name -> edx -> arg[0]
name_size -> ecx -> arg[1]
start_address -> ebx -> arg[2]
size -> edi -> arg[3]
```

**用户进程的虚拟空间**

```
  KERNBASE ------------> +---------------------------------+ 0xC0000000
                         |         Invalid Memory ()       | --/--
  USERTOP -------------> +---------------------------------+ 0xB0000000
                         |           User stack            |
                         +---------------------------------+
                         |                                 |
                         :                                 :
                         |         ~~~~~~~~~~~~~~~~        |
                         :                                 :
                         |                                 |
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         |       User Program & Heap       |
  UTEXT ---------------> +---------------------------------+ 0x00800000
                         |         Invalid Memory ()       | --/--
                         |  - - - - - - - - - - - - - - -  |
                         |    User STAB Data (optional)    |
  USERBASE, USTAB------> +---------------------------------+ 0x00200000
                         |         Invalid Memory ()       | --/--
  0 -------------------> +---------------------------------+ 0x00000000
```

**线程切换**

当所有进程都创建好后，内核线程切换是主动调用`schedule()`，就直接经过`switch_to`，eip就变成了下个线程调用`schedule()`时的地址。而每个用户线程都有一个内核栈空间，利用系统调用可以进行切换，栈空间先变成内核栈，在调用`schedule()`切换到下一个用户线程的内核栈，由上下文和中断返回，可以返回至下一用户线程的用户栈空间。
