#### 练习3：分析bootloader 进入保护模式的过程。

从`%cs=0 $pc=0x7c00`，进入后

首先清理环境：包括将flag置0和将段寄存器置0
```
	.code16
	    cli
	    cld
	    xorw %ax, %ax
	    movw %ax, %ds
	    movw %ax, %es
	    movw %ax, %ss
```

开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用，
可以访问4G的内存空间。
```
	seta20.1:               ## 等待8042键盘控制器不忙
	    inb $0x64, %al      ## 
	    testb $0x2, %al     #
	    jnz seta20.1        #
	
	    movb $0xd1, %al     ## 发送写8042输出端口的指令
	    outb %al, $0x64     #
	
	seta20.1:               ## 等待8042键盘控制器不忙
	    inb $0x64, %al      ## 
	    testb $0x2, %al     #
	    jnz seta20.1        #
	
	    movb $0xdf, %al     ## 打开A20
	    outb %al, $0x60     ## 
```

初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可
```
	    lgdt gdtdesc
```

进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式
```
	movl %cr0, %eax
	orl $CR0_PE_ON, %eax
	movl %eax, %cr0
```

通过长跳转更新cs的基地址
```
	ljmp $PROT_MODE_CSEG, $protcseg
.code32
protcseg:
```

设置段寄存器，并建立堆栈
```
	movw $PROT_MODE_DSEG, %ax
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %fs
	movw %ax, %gs
	movw %ax, %ss
	movl $0x0, %ebp
	movl $start, %esp
```
转到保护模式完成，进入boot主方法
```
	call bootmain
```

